{"remainingRequest":"/home/vimalesh/Learning/devops_ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vimalesh/Learning/devops_ui/src/portal/components/LineChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/vimalesh/Learning/devops_ui/src/portal/components/LineChart.vue","mtime":1660042032583},{"path":"/home/vimalesh/Learning/devops_ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vimalesh/Learning/devops_ui/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/vimalesh/Learning/devops_ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vimalesh/Learning/devops_ui/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBfIGZyb20gImxvZGFzaCI7CmltcG9ydCBQb3BwZXIgZnJvbSAicG9wcGVyLmpzIjsKaW1wb3J0IHsgc2NhbGVUaW1lLCBzY2FsZUxpbmVhciwgc2NhbGVPcmRpbmFsIH0gZnJvbSAiZDMtc2NhbGUiOwppbXBvcnQgeyBsaW5lIH0gZnJvbSAiZDMtc2hhcGUiOwppbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCwgbW91c2UgfSBmcm9tICJkMy1zZWxlY3Rpb24iOwppbXBvcnQgeyBiaXNlY3RvciwgZXh0ZW50LCBtYXggfSBmcm9tICJkMy1hcnJheSI7CmltcG9ydCB7IGF4aXNCb3R0b20sIGF4aXNMZWZ0IH0gZnJvbSAiZDMtYXhpcyI7CmltcG9ydCB7IHNjaGVtZUNhdGVnb3J5MTAgfSBmcm9tICJkMy1zY2FsZS1jaHJvbWF0aWMiOwppbXBvcnQgeyB0cmFuc2l0aW9uIH0gZnJvbSAiZDMtdHJhbnNpdGlvbiI7CmltcG9ydCB7IHRpbWVQYXJzZSwgdGltZUZvcm1hdCB9IGZyb20gImQzLXRpbWUtZm9ybWF0IjsKaW1wb3J0IHsgZm9ybWF0IGFzIGQzZm9ybWF0IH0gZnJvbSAiZDMtZm9ybWF0IjsKaW1wb3J0IHsKICB0aW1lU2Vjb25kLAogIHRpbWVNaW51dGUsCiAgdGltZUhvdXIsCiAgdGltZURheSwKICB0aW1lTW9udGgsCiAgdGltZVdlZWssCiAgdGltZVllYXIKfSBmcm9tICJkMy10aW1lIjsKY29uc3QgZDMgPSB7CiAgc2VsZWN0LAogIHNlbGVjdEFsbCwKICBtb3VzZSwKICBiaXNlY3RvciwKICBleHRlbnQsCiAgbWF4LAogIGF4aXNCb3R0b20sCiAgYXhpc0xlZnQsCiAgdHJhbnNpdGlvbiwKICB0aW1lUGFyc2UsCiAgdGltZUZvcm1hdCwKICB0aW1lU2Vjb25kLAogIHRpbWVNaW51dGUsCiAgdGltZUhvdXIsCiAgdGltZURheSwKICB0aW1lTW9udGgsCiAgdGltZVdlZWssCiAgdGltZVllYXIsCiAgbGluZSwKICBzY2hlbWVDYXRlZ29yeTEwLAogIHNjYWxlVGltZSwKICBzY2FsZUxpbmVhciwKICBzY2FsZU9yZGluYWwsCiAgZm9ybWF0OiBkM2Zvcm1hdAp9OwoKZXhwb3J0IGRlZmF1bHQgewogIHByb3BzOiB7CiAgICBjaGFydElkOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogKCkgPT4gYGxpbmVjaGFydC0ke0RhdGUubm93KCl9YAogICAgfSwKICAgIGNvbG9yczogeyB0eXBlOiBBcnJheSwgZGVmYXVsdDogKCkgPT4gZDMuc2NoZW1lQ2F0ZWdvcnkxMCB9LAogICAgd2lkdGg6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAiMTAwJSIgfSwKICAgIGhlaWdodDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICIzMDBweCIgfSwKICAgIHhBeGlzTGFiZWw6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0sCiAgICB5QXhpc0xhYmVsOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogbnVsbCB9LAogICAgeEtleTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIC8qIGRhdGUgKi8gfSwKICAgIHlLZXk6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSAvKiBwcmljZSAqLyB9LAogICAgaW50ZXJ2YWw6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAieWVhciIgfSwKICAgIGRhdGE6IHsKICAgICAgdHlwZTogQXJyYXksCiAgICAgIGRlZmF1bHQ6ICgpID0+IFtdCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgb3JkaW5hbENvbG9ycygpIHsKICAgICAgcmV0dXJuIGQzLnNjYWxlT3JkaW5hbCh0aGlzLmNvbG9ycyk7CiAgICB9LAogICAgY2hhcnRTdHlsZSgpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICB3aWR0aDogdGhpcy53aWR0aCwKICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0CiAgICAgIH07CiAgICB9LAogICAgaGFzRGF0YSgpIHsKICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggIT09IDA7CiAgICB9LAogICAgaGFzWEtleSgpIHsKICAgICAgcmV0dXJuICEhdGhpcy54S2V5OwogICAgfSwKICAgIGhhc1lLZXkoKSB7CiAgICAgIHJldHVybiAhIXRoaXMueUtleTsKICAgIH0sCiAgICBpc0NoYXJ0T3B0aW9uc1ZhbGlkKCkgewogICAgICByZXR1cm4gdGhpcy5oYXNEYXRhICYmIHRoaXMuaGFzWEtleSAmJiB0aGlzLmhhc1lLZXk7CiAgICB9LAogICAgY2hhcnREYXRhKCkgewogICAgICBjb25zdCBwYXJzZURhdGUgPSBkYXRlID0+IHsKICAgICAgICBjb25zdCBkYXRlRm9ybWF0ID0gIiVkLyVtLyVZIjsKICAgICAgICBjb25zdCByID0gZDMudGltZVBhcnNlKGRhdGVGb3JtYXQpKGRhdGUpOwogICAgICAgIGlmICghcikgdGhyb3cgRXJyb3IoYFN0cmluZyBkYXRlIGZvcm1hdCBleHBlY3RlZDogJHtkYXRlRm9ybWF0fWApOwogICAgICAgIHJldHVybiByOwogICAgICB9OwogICAgICByZXR1cm4gXy5tYXAodGhpcy5kYXRhLCBvID0+ICh7CiAgICAgICAgLi4ubywKICAgICAgICB2YWx1ZXM6IF8ubWFwKG8udmFsdWVzLCBkID0+ICh7CiAgICAgICAgICB4OiBwYXJzZURhdGUoZFt0aGlzLnhLZXldKSwKICAgICAgICAgIHk6ICtkW3RoaXMueUtleV0KICAgICAgICB9KSkKICAgICAgfSkpOwogICAgfSwKICAgIGNoYXJ0SGVpZ2h0KCkgewogICAgICByZXR1cm4gdGhpcy4kcmVmcy5jaGFydC5jbGllbnRIZWlnaHQ7CiAgICB9LAogICAgY2hhcnRXaWR0aCgpIHsKICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuY2hhcnQuY2xpZW50V2lkdGg7CiAgICB9LAogICAgdG9vbHRpcEVsKCkgewogICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtdG9vbHRpcD0nJHt0aGlzLmNoYXJ0SWR9J11gKTsKICAgIH0sCiAgICB4QXhpc01heCgpIHsKICAgICAgcmV0dXJuIF8ubWF4KHRoaXMuY2hhcnREYXRhLm1hcCgoeyB2YWx1ZXMgfSkgPT4gdmFsdWVzLmxlbmd0aCkpOwogICAgfSwKICAgIGxvbmdlc3RTZXJpZXMoKSB7CiAgICAgIHJldHVybiBfLmZpbmQodGhpcy5jaGFydERhdGEsIGQgPT4gZC52YWx1ZXMubGVuZ3RoID09PSB0aGlzLnhBeGlzTWF4KTsKICAgIH0sCiAgICB4QXhpc1RpY2tzQnlJbnRlcnZhbCgpIHsKICAgICAgY29uc3QgeyBpbnRlcnZhbCwgeEF4aXNNYXggfSA9IHRoaXM7CiAgICAgIGNvbnN0IGF4aXNCeSA9IHsKICAgICAgICAvLyB5ZWFyOiBkMy50aW1lWWVhciwKICAgICAgICAvLyBkYXk6IGQzLnRpbWVEYXksCiAgICAgICAgLy8gd2VlazogZDMudGltZVdlZWssCiAgICAgICAgLy8gbW9udGg6IGQzLnRpbWVNb250aAogICAgICB9OwogICAgICByZXR1cm4gYXhpc0J5W3hBeGlzTWF4XSB8fCB4QXhpc01heDsKICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBkYXRhKCkgewogICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7CiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBtdWx0aURhdGVGb3JtYXQoZGF0ZSwgaSA9IHRoaXMuZ2V0SW5kZXhPZkZvY3VzUG9pbnQoZGF0ZSkpIHsKICAgICAgLy8gY29uc3QgIGZvcm1hdE1pbGxpc2Vjb25kID0gZDMudGltZUZvcm1hdCgnLiVMJyksCiAgICAgIC8vIGZvcm1hdFNlY29uZCA9IGQzLnRpbWVGb3JtYXQoJzolUycpLAogICAgICAvLyBmb3JtYXRNaW51dGUgPSBkMy50aW1lRm9ybWF0KCclSTolTScpLAogICAgICAvLyBmb3JtYXRIb3VyID0gZDMudGltZUZvcm1hdCgnJUkgJXAnKSwKICAgICAgLy8gZm9ybWF0V2VlayA9IGQzLnRpbWVGb3JtYXQoJ1dlZWsgJVUnKSwKICAgICAgLy8gZm9ybWF0TW9udGggPSBkMy50aW1lRm9ybWF0KCclQicpLAoKICAgICAgY29uc3QgZm9ybWF0QnkgPSB7CiAgICAgICAgZGF5OiBkMy50aW1lRm9ybWF0KCIlYiAlWSIpLAogICAgICAgIC8vIHdlZWs6IGQzLnRpbWVGb3JtYXQoYFdlZWsgJHtpICsgMX1gKSwKICAgICAgICBtb250aDogZDMudGltZUZvcm1hdCgiJUIiKSwKICAgICAgICBxdWFydGVyOiBkMy50aW1lRm9ybWF0KGBRdWFydGVyICR7aSArIDF9YCksCiAgICAgICAgeWVhcjogZDMudGltZUZvcm1hdCgiJVkiKQogICAgICB9OwoKICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0QnlbdGhpcy5pbnRlcnZhbF07CiAgICAgIC8vIGNvbnN0IGZvcm1hdHRlciA9CiAgICAgIC8vICAgKGQzLnRpbWVTZWNvbmQoZGF0ZSkgPCBkYXRlICYmIGZvcm1hdE1pbGxpc2Vjb25kKSB8fAogICAgICAvLyAgIChkMy50aW1lTWludXRlKGRhdGUpIDwgZGF0ZSAmJiBmb3JtYXRTZWNvbmQpIHx8CiAgICAgIC8vICAgKGQzLnRpbWVIb3VyKGRhdGUpIDwgZGF0ZSAmJiBmb3JtYXRNaW51dGUpIHx8CiAgICAgIC8vICAgKGQzLnRpbWVEYXkoZGF0ZSkgPCBkYXRlICYmIGZvcm1hdEhvdXIpIHx8CiAgICAgIC8vICAgKGQzLnRpbWVNb250aChkYXRlKSA8IGRhdGUKICAgICAgLy8gICAgID8gKGQzLnRpbWVXZWVrKGRhdGUpIDwgZGF0ZSAmJiBmb3JtYXREYXkpIHx8IGZvcm1hdFdlZWsKICAgICAgLy8gICAgIDogKGQzLnRpbWVZZWFyKGRhdGUpIDwgZGF0ZSAmJiBmb3JtYXRNb250aCkgfHwgZm9ybWF0WWVhcik7CgogICAgICAvLyBjb25zb2xlLmxvZyhgJHtkYXRlfSBmb3JtYXR0ZXI6YCwgZm9ybWF0dGVyKTsKICAgICAgcmV0dXJuIGZvcm1hdHRlciAmJiBfLmVzY2FwZShmb3JtYXR0ZXIoZGF0ZSkpOwogICAgfSwKCiAgICBnZXREYXR1bUluU2VyaWVzKHsgc2VyaWVzOiB7IHZhbHVlcyB9LCB4UG9pbnQsIGZvY3VzUG9pbnQgfSkgewogICAgICBjb25zdCBiaXNlY3REYXRlID0gZDMuYmlzZWN0b3IoZCA9PiBkLngpLmxlZnQ7CiAgICAgIGNvbnN0IGkgPSBiaXNlY3REYXRlKHZhbHVlcywgeFBvaW50LCAxKTsKICAgICAgY29uc3QgZDAgPSB2YWx1ZXNbaSAtIDFdOwogICAgICBjb25zdCBkMSA9IHZhbHVlc1tpXSB8fCB7fTsKICAgICAgY29uc3QgY2xvc2VzdEQgPSB4UG9pbnQgLSBkMC54ID4gZDEueCAtIHhQb2ludCA/IGQxIDogZDA7CiAgICAgIGNvbnN0IHhQb2ludE1pbnVzQ2xvc2VzdEQgPSBNYXRoLmFicyh4UG9pbnQgLSBjbG9zZXN0RC54KTsKICAgICAgY29uc3QgZm9jdXNQb2ludE1pbnVzWFBvaW50ID0gTWF0aC5hYnMoeFBvaW50IC0gZm9jdXNQb2ludCk7CiAgICAgIGNvbnN0IHIgPSBmb2N1c1BvaW50CiAgICAgICAgPyB4UG9pbnRNaW51c0Nsb3Nlc3REID4gZm9jdXNQb2ludE1pbnVzWFBvaW50CiAgICAgICAgICA/IG51bGwKICAgICAgICAgIDogY2xvc2VzdEQKICAgICAgICA6IGNsb3Nlc3REOwogICAgICAvLyBjb25zb2xlLmxvZyhgcjpgLCByKTsKICAgICAgcmV0dXJuIHI7CiAgICB9LAogICAgZ2V0RGF0ZVNhbnNUaW1lKGRhdGUpIHsKICAgICAgcmV0dXJuIGAke2RhdGUuZ2V0RGF0ZSgpfS0ke2RhdGUuZ2V0TW9udGgoKX0tJHtkYXRlLmdldEZ1bGxZZWFyKCl9YDsKICAgIH0sCiAgICBnZXRJbmRleE9mRm9jdXNQb2ludChmb2N1c1BvaW50KSB7CiAgICAgIGNvbnN0IHsgZ2V0RGF0ZVNhbnNUaW1lLCBsb25nZXN0U2VyaWVzIH0gPSB0aGlzOwogICAgICByZXR1cm4gXy5maW5kSW5kZXgoCiAgICAgICAgbG9uZ2VzdFNlcmllcy52YWx1ZXMsCiAgICAgICAgZCA9PiBnZXREYXRlU2Fuc1RpbWUoZC54KSA9PT0gZ2V0RGF0ZVNhbnNUaW1lKGZvY3VzUG9pbnQpCiAgICAgICk7CiAgICB9LAogICAgaW5pdFRvb2x0aXBQb3BwZXIodG9vbHRpcFJlZkVsLCB0b29sdGlwRWwpIHsKICAgICAgcmV0dXJuIG5ldyBQb3BwZXIodG9vbHRpcFJlZkVsLCB0b29sdGlwRWwsIHsKICAgICAgICBwbGFjZW1lbnQ6ICJsZWZ0IiwKICAgICAgICBtb2RpZmllcnM6IHsKICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzogewogICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5jaGFydElkfWApCiAgICAgICAgICB9LAogICAgICAgICAgb2Zmc2V0OiB7CiAgICAgICAgICAgIG9mZnNldDogIjAsIDhweCIKICAgICAgICAgIH0sCiAgICAgICAgICBmbGlwOiB7IGJlaGF2aW9yOiBbImxlZnQiLCAicmlnaHQiXSB9CiAgICAgICAgfQogICAgICB9KTsKICAgIH0sCiAgICBjb21wb3NlVG9vbHRpcEhUTUwoeyBmb2N1c0RhdGFQb2ludHMsIGZvY3VzUG9pbnQgfSkgewogICAgICByZXR1cm4gYAogICAgICAgIDxkaXYgY2xhc3M9ImxpbmUtY2hhcnQtdG9vbHRpcC10aXRsZSI+JHt0aGlzLm11bHRpRGF0ZUZvcm1hdCgKICAgICAgICAgIGZvY3VzUG9pbnQKICAgICAgICApfTwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9InNlcmllcy1jb250YWluZXIiPgogICAgICAgICAgJHtmb2N1c0RhdGFQb2ludHMKICAgICAgICAgICAgLm1hcCgKICAgICAgICAgICAgICBkID0+IGAKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlcmllcy1yb3ciPgogICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iY29sb3ItYmFyIiBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjoke18uZXNjYXBlKAogICAgICAgICAgICAgICAgICAgIGQuY29sb3IKICAgICAgICAgICAgICAgICAgKX0iPiZuYnNwOzwvc3Bhbj4KICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VyaWVzLWluZm8iPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlcmllcy1uYW1lIj4ke18uZXNjYXBlKGQuc2VyaWVzKX08L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZXJpZXMtdmFsdWUiPiR7Xy5lc2NhcGUoZC55KX08L2Rpdj4KICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICBgCiAgICAgICAgICAgICkKICAgICAgICAgICAgLmpvaW4oIiIpfQogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9InBvcHBlci1hcnJvdyIgeC1hcnJvdz0iIj48L2Rpdj4KICAgICAgYDsKICAgIH0sCiAgICByZW5kZXJDaGFydCgpIHsKICAgICAgY29uc3QgYyA9IHRoaXM7CiAgICAgIGNvbnN0IHsKICAgICAgICBvcmRpbmFsQ29sb3JzOiBjb2xvcnMsCiAgICAgICAgY2hhcnREYXRhOiBkYXRhLAogICAgICAgIGlzQ2hhcnRPcHRpb25zVmFsaWQsCiAgICAgICAgY2hhcnRJZCwKICAgICAgICBjaGFydFdpZHRoLAogICAgICAgIGNoYXJ0SGVpZ2h0LAogICAgICAgIGdldERhdHVtSW5TZXJpZXMsCiAgICAgICAgdG9vbHRpcEVsLAogICAgICAgIG11bHRpRGF0ZUZvcm1hdCwKICAgICAgICBsb25nZXN0U2VyaWVzLAogICAgICAgIHhBeGlzVGlja3NCeUludGVydmFsLAogICAgICAgIGluaXRUb29sdGlwUG9wcGVyLAogICAgICAgIGNvbXBvc2VUb29sdGlwSFRNTCwKICAgICAgICB4QXhpc0xhYmVsLAogICAgICAgIHlBeGlzTGFiZWwKICAgICAgfSA9IGM7CiAgICAgIGlmICghaXNDaGFydE9wdGlvbnNWYWxpZCkgcmV0dXJuOwoKICAgICAgY29uc3QgYXhpc09mZnNldCA9IDE2OwogICAgICBjb25zdCBsYWJlbE9mZnNldCA9IDIxICogMS43NSArIGF4aXNPZmZzZXQ7CgogICAgICBjb25zdCBtYXJnaW4gPSB7CiAgICAgICAgdG9wOiAzMCwKICAgICAgICBsZWZ0OiAxMDAgKyAoeUF4aXNMYWJlbCA/IGxhYmVsT2Zmc2V0IDogMCksCiAgICAgICAgcmlnaHQ6IDMwLAogICAgICAgIGJvdHRvbTogMzAgKyAoeEF4aXNMYWJlbCA/IGxhYmVsT2Zmc2V0IDogMCkKICAgICAgfTsKICAgICAgY29uc3Qgd2lkdGggPSBjaGFydFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7CiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0SGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207CgogICAgICAvKiBTY2FsZXMgKi8KICAgICAgY29uc3QgeFNjYWxlID0gZDMKICAgICAgICAuc2NhbGVUaW1lKCkKICAgICAgICAuZG9tYWluKGQzLmV4dGVudChsb25nZXN0U2VyaWVzLnZhbHVlcywgZCA9PiBkLngpKQogICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTsKICAgICAgCiAgICAgIGNvbnN0IHlTY2FsZSA9IGQzCiAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgobG9uZ2VzdFNlcmllcy52YWx1ZXMsIGQgPT4gZC55KV0pCiAgICAgICAgLnJhbmdlKFtoZWlnaHQgLSAwLCAwXSk7CgogICAgICAvKiBkcmF3IGxpbmUgZm4gZm9yIGVhY2ggc2VyaWVzICovCiAgICAgIGNvbnN0IGRyYXdMaW5lID0gKHsgdmFsdWVzIH0pID0+CiAgICAgICAgZDMKICAgICAgICAgIC5saW5lKCkKICAgICAgICAgIC54KGQgPT4geFNjYWxlKGQueCkpCiAgICAgICAgICAueShkID0+IHlTY2FsZShkLnkpKSh2YWx1ZXMpOwoKICAgICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdCh0b29sdGlwRWwpOwoKICAgICAgLyogcmVtb3ZlIHByZXZpb3VzbHkgcmVuZGVyZWQsIGlmIGFueSAqLwogICAgICBkMy5zZWxlY3QoYCMke2NoYXJ0SWR9IHN2Z2ApLnJlbW92ZSgpOwogICAgICBkMy5zZWxlY3QoYCMke2NoYXJ0SWR9IGRpdmApLnJlbW92ZSgpOwogICAgICB0b29sdGlwLmh0bWwoIiIpOwoKICAgICAgLyogU1ZHICovCiAgICAgIGNvbnN0IHN2ZyA9IGQzCiAgICAgICAgLnNlbGVjdChgIyR7Y2hhcnRJZH1gKQogICAgICAgIC5hcHBlbmQoInN2ZyIpCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCArICJweCIpCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgInB4Iik7CgogICAgICAvKiBwb3NpdGlvbiBtYWluIGcgZWxlbWVudCAqLwogICAgICBjb25zdCBnID0gc3ZnCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sICR7bWFyZ2luLnRvcH0pYCk7CgogICAgICAvKiBhZGQgYXhlcyAqLwogICAgICBjb25zdCB4QXhpcyA9IGQzCiAgICAgICAgLmF4aXNCb3R0b20oeFNjYWxlKQogICAgICAgIC8vIC50aWNrU2l6ZSgwKQogICAgICAgIC50aWNrRm9ybWF0KG11bHRpRGF0ZUZvcm1hdCkKICAgICAgICAudGlja3MoeEF4aXNUaWNrc0J5SW50ZXJ2YWwpOwoKICAgICAgZy5hcHBlbmQoImciKQogICAgICAgIC5hdHRyKCJjbGFzcyIsICJ4IGF4aXMiKQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0fSlgKQogICAgICAgIC5jYWxsKHhBeGlzKQogICAgICAgIC5zZWxlY3RBbGwoInRleHQiKQogICAgICAgIC5hdHRyKCJ5IiwgYXhpc09mZnNldCk7CgogICAgICBjb25zdCB5QXhpcyA9IGQzCiAgICAgICAgLmF4aXNMZWZ0KHlTY2FsZSkKICAgICAgICAudGlja1NpemUoLXdpZHRoKQogICAgICAgIC50aWNrcyg1KQogICAgICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgiIikpCiAgICAgICAgLnNjYWxlKHlTY2FsZS5uaWNlKCkpOwoKICAgICAgZy5hcHBlbmQoImciKQogICAgICAgIC5hdHRyKCJjbGFzcyIsICJ5IGF4aXMiKQogICAgICAgIC5jYWxsKHlBeGlzKQogICAgICAgIC5zZWxlY3RBbGwoInRleHQiKQogICAgICAgIC5hdHRyKCJ4IiwgLWF4aXNPZmZzZXQpOwoKICAgICAgLy8gQWRkIFggYXhpcyBsYWJlbAogICAgICBjb25zdCB4QXhpc1RpY2tzQXBwcm94SGVpZ2h0ID0gMzA7CiAgICAgIGNvbnN0IHhMYWJlbE9mZnNldCA9IHhBeGlzVGlja3NBcHByb3hIZWlnaHQgKyAyMTsKICAgICAgc3ZnCiAgICAgICAgLnNlbGVjdCgiLnguYXhpcyIpCiAgICAgICAgLmFwcGVuZCgidGV4dCIpCiAgICAgICAgLnRleHQoeEF4aXNMYWJlbCkKICAgICAgICAuYXR0cigiY2xhc3MiLCAibGluZS1ncmFwaC1sYWJlbCIpCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt3aWR0aCAvIDJ9LCAke3hMYWJlbE9mZnNldH0pYCk7CgogICAgICAvLyBBZGQgWSBheGlzIGxhYmVsCiAgICAgIHN2ZwogICAgICAgIC5zZWxlY3QoIi55LmF4aXMiKQogICAgICAgIC5hcHBlbmQoInRleHQiKQogICAgICAgIC50ZXh0KHlBeGlzTGFiZWwpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgImxpbmUtZ3JhcGgtbGFiZWwiKQogICAgICAgIC5hdHRyKAogICAgICAgICAgInRyYW5zZm9ybSIsCiAgICAgICAgICBgdHJhbnNsYXRlKCR7LWxhYmVsT2Zmc2V0fSwgJHsoaGVpZ2h0IC0gbWFyZ2luLnRvcCkgLyAyfSkgcm90YXRlKC05MClgCiAgICAgICAgKTsKCiAgICAgIC8qIGFkZCBzZXJpZXMgbGluZXMgKi8KICAgICAgY29uc3QgbGluZXMgPSBnLmFwcGVuZCgiZyIpLmF0dHIoImNsYXNzIiwgImxpbmVzIik7CgogICAgICBjb25zdCBzZXJpZXMgPSBsaW5lcwogICAgICAgIC5zZWxlY3RBbGwoIi5saW5lLWdyb3VwIikKICAgICAgICAuZGF0YShkYXRhKQogICAgICAgIC5lbnRlcigpCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgImxpbmUtZ3JvdXAiKTsKCiAgICAgIHNlcmllcwogICAgICAgIC5hcHBlbmQoInBhdGgiKQogICAgICAgIC5hdHRyKCJjbGFzcyIsICJsaW5lIikKICAgICAgICAuYXR0cigiZCIsIGQgPT4gZHJhd0xpbmUoZCkpCiAgICAgICAgLnN0eWxlKCJzdHJva2UiLCAoZCwgaSkgPT4gY29sb3JzKGkpKQogICAgICAgIC5zdHlsZSgib3BhY2l0eSIsICIwLjg1Iik7CgogICAgICAvKiBUb29sdGlwIHJlZmVyZW5jZSBwb2ludCAqLwogICAgICBjb25zdCB0b29sdGlwUmVmID0gZDMKICAgICAgICAuc2VsZWN0KGAjJHtjaGFydElkfWApCiAgICAgICAgLmFwcGVuZCgiZGl2IikKICAgICAgICAuYXR0cigiY2xhc3MiLCAidG9vbHRpcC1yZWYiKTsKCiAgICAgIGxldCB0b29sdGlwUG9wcGVyOyAvKiBpbml0IG9uY2UsIHJldXNlIHBvcHBlciAqLwoKICAgICAgY29uc3Qgb3ZlcmxheSA9IGcuYXBwZW5kKCJyZWN0Iik7CiAgICAgIG92ZXJsYXkKICAgICAgICAuYXR0cigiY2xhc3MiLCAib3ZlcmxheSIpCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCkKICAgICAgICAub24oIm1vdXNlbW92ZSIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgY29uc3QgW21vdXNlWF0gPSBkMy5tb3VzZSh0aGlzKTsKICAgICAgICAgIGNvbnN0IHhQb2ludCA9IHhTY2FsZS5pbnZlcnQobW91c2VYKTsKICAgICAgICAgIGNvbnN0IGZvY3VzRGF0YVBvaW50cyA9IFtdOyAvKiBhbGwgZG90cyBvbiBmb2N1c2VkIHhBeGlzICovCgogICAgICAgICAgZy5zZWxlY3RBbGwoIi5jaXJjbGUiKS5yZW1vdmUoKTsgLyogcmVtb3ZlIHJlbmRlcmVkIGRvdHMgKi8KCiAgICAgICAgICAvKiBkZXRlcm1pbmUgZm9jdXMgcG9pbnQgZnJvbSBtb3VzZSBob3ZlciBYICovCiAgICAgICAgICBjb25zdCB7IHg6IGZvY3VzUG9pbnQgfSA9IGdldERhdHVtSW5TZXJpZXMoewogICAgICAgICAgICBzZXJpZXM6IGxvbmdlc3RTZXJpZXMsCiAgICAgICAgICAgIHhQb2ludAogICAgICAgICAgfSk7CgogICAgICAgICAgLyogZm9yIGVhY2ggc2VyaWVzLCByZW5kZXIgZG90LCBwdXNoIHRvIGFycmF5IGZvciB0b29sdGlwIHJlbmRlciAqLwogICAgICAgICAgZGF0YS5mb3JFYWNoKChzZXJpZXMsIGkpID0+IHsKICAgICAgICAgICAgY29uc3QgZCA9IGdldERhdHVtSW5TZXJpZXMoeyBzZXJpZXMsIHhQb2ludCwgZm9jdXNQb2ludCB9KTsKICAgICAgICAgICAgaWYgKCFkKSByZXR1cm47IC8qIHNraXAgaWYgbm90IGZvY3VzIHBvaW50ICovCiAgICAgICAgICAgIGZvY3VzRGF0YVBvaW50cy5wdXNoKHsKICAgICAgICAgICAgICAuLi5kLAogICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLm5hbWUsCiAgICAgICAgICAgICAgY29sb3I6IGNvbG9ycyhpKQogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIC8qIGRvdCBvbiBmb2N1cyBwb2ludCAqLwogICAgICAgICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSAzOwogICAgICAgICAgICBnLmFwcGVuZCgiZyIpCiAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgImNpcmNsZSIpCiAgICAgICAgICAgICAgLmFwcGVuZCgiY2lyY2xlIikKICAgICAgICAgICAgICAuc3R5bGUoImZpbGwiLCBjb2xvcnMoaSkpCiAgICAgICAgICAgICAgLmF0dHIoImN4IiwgeFNjYWxlKGQueCkpCiAgICAgICAgICAgICAgLmF0dHIoImN5IiwgeVNjYWxlKGQueSkpCiAgICAgICAgICAgICAgLmF0dHIoInIiLCBjaXJjbGVSYWRpdXMpOwogICAgICAgICAgfSk7CiAgICAgICAgICAvKiB1cGRhdGUgdG9vbHRpcCByZWZlcmVuY2UgcG9zaXRpb24gKi8KICAgICAgICAgIHRvb2x0aXBSZWYKICAgICAgICAgICAgLnN0eWxlKCJsZWZ0IiwgYGNhbGMoJHt4U2NhbGUoZm9jdXNQb2ludCl9cHggKyAke21hcmdpbi5sZWZ0fXB4KWApCiAgICAgICAgICAgIC5zdHlsZSgidHJhbnNmb3JtIiwgYHRyYW5zbGF0ZVkoLTUwJSlgKQogICAgICAgICAgICAuc3R5bGUoInRvcCIsIGBjYWxjKDUwJSAtICR7bWFyZ2luLnRvcH1weClgKTsKCiAgICAgICAgICAvKiBjb21wb3NlIEhUTUwgZm9yIHRvb2x0aXAgKi8KICAgICAgICAgIHRvb2x0aXAuc3R5bGUoImRpc3BsYXkiLCAiaW5oZXJpdCIpLmh0bWwoCiAgICAgICAgICAgIGNvbXBvc2VUb29sdGlwSFRNTCh7CiAgICAgICAgICAgICAgZm9jdXNEYXRhUG9pbnRzLAogICAgICAgICAgICAgIGZvY3VzUG9pbnQKICAgICAgICAgICAgfSkKICAgICAgICAgICk7CgogICAgICAgICAgLyogaW5pdCBwb3BwZXIgb25jZSAqLwogICAgICAgICAgaWYgKCF0b29sdGlwUG9wcGVyKSB7CiAgICAgICAgICAgIGNvbnN0IFt0b29sdGlwUmVmRWxdID0gdG9vbHRpcFJlZi5ub2RlcygpOwogICAgICAgICAgICB0b29sdGlwUG9wcGVyID0gaW5pdFRvb2x0aXBQb3BwZXIodG9vbHRpcFJlZkVsLCB0b29sdGlwRWwpOwogICAgICAgICAgfQogICAgICAgICAgLyogdXBkYXRlIHBvcHBlciBvbiBtb3VzZW1vdmUgKi8KICAgICAgICAgIGlmICh0b29sdGlwUG9wcGVyKSB0b29sdGlwUG9wcGVyLnVwZGF0ZSgpOwogICAgICAgIH0pCiAgICAgICAgLm9uKCJtb3VzZW91dCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgY29uc3QgW21vdXNlWCwgbW91c2VZXSA9IGQzLm1vdXNlKHRoaXMpOwogICAgICAgICAgY29uc3QgbWF4V2lkdGggPSBvdmVybGF5Lm5vZGUoKS5nZXRBdHRyaWJ1dGUoIndpZHRoIik7CiAgICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBvdmVybGF5Lm5vZGUoKS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpOwogICAgICAgICAgLyogcmVtb3ZlIGRvdHMgYW5kIHRvb2x0aXBzICovCiAgICAgICAgICBpZiAoCiAgICAgICAgICAgIG1vdXNlWCA8IDAgfHwKICAgICAgICAgICAgbW91c2VYID49IG1heFdpZHRoIHx8CiAgICAgICAgICAgIG1vdXNlWSA8IDAgfHwKICAgICAgICAgICAgbW91c2VZID49IG1heEhlaWdodAogICAgICAgICAgKSB7CiAgICAgICAgICAgIGcuc2VsZWN0QWxsKCIuY2lyY2xlIikucmVtb3ZlKCk7CiAgICAgICAgICAgIHRvb2x0aXAuaHRtbCgiIik7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9LAogICAgZ3JhcGhfbGFiZWwodmFsKXsKICAgIGxldCBuYW1lX2tleSA9IHsKICAgICAgJ2FsbCBjb252ZXJzYXRpb25zJzonYWxsX2NvbnZlcnNhdGlvbnMnLAogICAgICAndXNlciBpbml0aWF0ZWQnOid1c2VyX2luaXRpYXRlZCcsCiAgICAgICdidXNpbmVzcyBpbml0aWF0ZWQnOididXNpbmVzc19pbml0aWF0ZWQnLAogICAgICAnZnJlZSB0aWVyJzogJ2ZyZWVfdGllcicsCiAgICAgICdmcmVlIGVudHJ5JzonZnJlZV9lbnRyeScsCiAgICAgICdmcmVlIGNvbnZlcnNhdGlvbnMnOidmcmVlX2NvbnZlcnNhdGlvbnMnLAogICAgICAnYWxsIHBhaWQnOidhbGxfcGFpZCcsCiAgICAgICd0b3RhbCc6J3RvdGFsJwogICAgfQogICAgIHJldHVybiBPYmplY3Qua2V5cyhuYW1lX2tleSkuZmluZChrZXkgPT4gbmFtZV9rZXlba2V5XSA9PT0gdmFsKTsKICAgIH0KICB9LAogIG1vdW50ZWQoKSB7CiAgICB0aGlzLnJlbmRlckNoYXJ0KCk7CiAgfQp9Owo="},{"version":3,"sources":["LineChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"LineChart.vue","sourceRoot":"src/portal/components","sourcesContent":["<template>\n  <section data-root>\n    <div data-line-chart :id=\"chartId\" ref=\"chart\" :style=\"chartStyle\">\n      <div v-if=\"!isChartOptionsValid\" class=\"invalid-options\">\n        <div>Line Chart</div>\n        <div v-if=\"!hasData\">No chart data provided</div>\n        <div v-if=\"!hasXKey\">No x-axis key defined for data</div>\n        <div v-if=\"!hasYKey\">No y-axis key defined for data</div>\n      </div>\n    </div>\n    <div data-line-chart-legend>\n      <div class=\"legend-key\">Key</div>\n      <ul>\n        <li class=\"legend-series\" v-for=\"(d,i) in chartData\" :key=\"d.name\">\n          <div class=\"legend-icon\" :style=\"`background-color: ${ordinalColors(i)}`\"></div>\n          <div class=\"legend-text\">{{graph_label(d.name)}}</div>\n        </li>\n      </ul>\n    </div>\n    <div class=\"line-chart-tooltip\" :data-tooltip=\"chartId\"></div>\n  </section>\n</template>\n\n<script>\nimport _ from \"lodash\";\nimport Popper from \"popper.js\";\nimport { scaleTime, scaleLinear, scaleOrdinal } from \"d3-scale\";\nimport { line } from \"d3-shape\";\nimport { select, selectAll, mouse } from \"d3-selection\";\nimport { bisector, extent, max } from \"d3-array\";\nimport { axisBottom, axisLeft } from \"d3-axis\";\nimport { schemeCategory10 } from \"d3-scale-chromatic\";\nimport { transition } from \"d3-transition\";\nimport { timeParse, timeFormat } from \"d3-time-format\";\nimport { format as d3format } from \"d3-format\";\nimport {\n  timeSecond,\n  timeMinute,\n  timeHour,\n  timeDay,\n  timeMonth,\n  timeWeek,\n  timeYear\n} from \"d3-time\";\nconst d3 = {\n  select,\n  selectAll,\n  mouse,\n  bisector,\n  extent,\n  max,\n  axisBottom,\n  axisLeft,\n  transition,\n  timeParse,\n  timeFormat,\n  timeSecond,\n  timeMinute,\n  timeHour,\n  timeDay,\n  timeMonth,\n  timeWeek,\n  timeYear,\n  line,\n  schemeCategory10,\n  scaleTime,\n  scaleLinear,\n  scaleOrdinal,\n  format: d3format\n};\n\nexport default {\n  props: {\n    chartId: {\n      type: String,\n      default: () => `linechart-${Date.now()}`\n    },\n    colors: { type: Array, default: () => d3.schemeCategory10 },\n    width: { type: String, default: \"100%\" },\n    height: { type: String, default: \"300px\" },\n    xAxisLabel: { type: String, default: null },\n    yAxisLabel: { type: String, default: null },\n    xKey: { type: String, required: true /* date */ },\n    yKey: { type: String, required: true /* price */ },\n    interval: { type: String, default: \"year\" },\n    data: {\n      type: Array,\n      default: () => []\n    }\n  },\n  computed: {\n    ordinalColors() {\n      return d3.scaleOrdinal(this.colors);\n    },\n    chartStyle() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    },\n    hasData() {\n      return this.data.length !== 0;\n    },\n    hasXKey() {\n      return !!this.xKey;\n    },\n    hasYKey() {\n      return !!this.yKey;\n    },\n    isChartOptionsValid() {\n      return this.hasData && this.hasXKey && this.hasYKey;\n    },\n    chartData() {\n      const parseDate = date => {\n        const dateFormat = \"%d/%m/%Y\";\n        const r = d3.timeParse(dateFormat)(date);\n        if (!r) throw Error(`String date format expected: ${dateFormat}`);\n        return r;\n      };\n      return _.map(this.data, o => ({\n        ...o,\n        values: _.map(o.values, d => ({\n          x: parseDate(d[this.xKey]),\n          y: +d[this.yKey]\n        }))\n      }));\n    },\n    chartHeight() {\n      return this.$refs.chart.clientHeight;\n    },\n    chartWidth() {\n      return this.$refs.chart.clientWidth;\n    },\n    tooltipEl() {\n      return document.querySelector(`[data-tooltip='${this.chartId}']`);\n    },\n    xAxisMax() {\n      return _.max(this.chartData.map(({ values }) => values.length));\n    },\n    longestSeries() {\n      return _.find(this.chartData, d => d.values.length === this.xAxisMax);\n    },\n    xAxisTicksByInterval() {\n      const { interval, xAxisMax } = this;\n      const axisBy = {\n        // year: d3.timeYear,\n        // day: d3.timeDay,\n        // week: d3.timeWeek,\n        // month: d3.timeMonth\n      };\n      return axisBy[xAxisMax] || xAxisMax;\n    }\n  },\n  watch: {\n    data() {\n      this.renderChart();\n    }\n  },\n  methods: {\n    multiDateFormat(date, i = this.getIndexOfFocusPoint(date)) {\n      // const  formatMillisecond = d3.timeFormat('.%L'),\n      // formatSecond = d3.timeFormat(':%S'),\n      // formatMinute = d3.timeFormat('%I:%M'),\n      // formatHour = d3.timeFormat('%I %p'),\n      // formatWeek = d3.timeFormat('Week %U'),\n      // formatMonth = d3.timeFormat('%B'),\n\n      const formatBy = {\n        day: d3.timeFormat(\"%b %Y\"),\n        // week: d3.timeFormat(`Week ${i + 1}`),\n        month: d3.timeFormat(\"%B\"),\n        quarter: d3.timeFormat(`Quarter ${i + 1}`),\n        year: d3.timeFormat(\"%Y\")\n      };\n\n      const formatter = formatBy[this.interval];\n      // const formatter =\n      //   (d3.timeSecond(date) < date && formatMillisecond) ||\n      //   (d3.timeMinute(date) < date && formatSecond) ||\n      //   (d3.timeHour(date) < date && formatMinute) ||\n      //   (d3.timeDay(date) < date && formatHour) ||\n      //   (d3.timeMonth(date) < date\n      //     ? (d3.timeWeek(date) < date && formatDay) || formatWeek\n      //     : (d3.timeYear(date) < date && formatMonth) || formatYear);\n\n      // console.log(`${date} formatter:`, formatter);\n      return formatter && _.escape(formatter(date));\n    },\n\n    getDatumInSeries({ series: { values }, xPoint, focusPoint }) {\n      const bisectDate = d3.bisector(d => d.x).left;\n      const i = bisectDate(values, xPoint, 1);\n      const d0 = values[i - 1];\n      const d1 = values[i] || {};\n      const closestD = xPoint - d0.x > d1.x - xPoint ? d1 : d0;\n      const xPointMinusClosestD = Math.abs(xPoint - closestD.x);\n      const focusPointMinusXPoint = Math.abs(xPoint - focusPoint);\n      const r = focusPoint\n        ? xPointMinusClosestD > focusPointMinusXPoint\n          ? null\n          : closestD\n        : closestD;\n      // console.log(`r:`, r);\n      return r;\n    },\n    getDateSansTime(date) {\n      return `${date.getDate()}-${date.getMonth()}-${date.getFullYear()}`;\n    },\n    getIndexOfFocusPoint(focusPoint) {\n      const { getDateSansTime, longestSeries } = this;\n      return _.findIndex(\n        longestSeries.values,\n        d => getDateSansTime(d.x) === getDateSansTime(focusPoint)\n      );\n    },\n    initTooltipPopper(tooltipRefEl, tooltipEl) {\n      return new Popper(tooltipRefEl, tooltipEl, {\n        placement: \"left\",\n        modifiers: {\n          preventOverflow: {\n            boundariesElement: document.querySelector(`#${this.chartId}`)\n          },\n          offset: {\n            offset: \"0, 8px\"\n          },\n          flip: { behavior: [\"left\", \"right\"] }\n        }\n      });\n    },\n    composeTooltipHTML({ focusDataPoints, focusPoint }) {\n      return `\n        <div class=\"line-chart-tooltip-title\">${this.multiDateFormat(\n          focusPoint\n        )}</div>\n        <div class=\"series-container\">\n          ${focusDataPoints\n            .map(\n              d => `\n                <div class=\"series-row\">\n                  <span class=\"color-bar\" style=\"background-color:${_.escape(\n                    d.color\n                  )}\">&nbsp;</span>\n                  <div class=\"series-info\">\n                    <div class=\"series-name\">${_.escape(d.series)}</div>\n                    <div class=\"series-value\">${_.escape(d.y)}</div>\n                  </div>\n                </div>\n              `\n            )\n            .join(\"\")}\n        </div>\n        <div class=\"popper-arrow\" x-arrow=\"\"></div>\n      `;\n    },\n    renderChart() {\n      const c = this;\n      const {\n        ordinalColors: colors,\n        chartData: data,\n        isChartOptionsValid,\n        chartId,\n        chartWidth,\n        chartHeight,\n        getDatumInSeries,\n        tooltipEl,\n        multiDateFormat,\n        longestSeries,\n        xAxisTicksByInterval,\n        initTooltipPopper,\n        composeTooltipHTML,\n        xAxisLabel,\n        yAxisLabel\n      } = c;\n      if (!isChartOptionsValid) return;\n\n      const axisOffset = 16;\n      const labelOffset = 21 * 1.75 + axisOffset;\n\n      const margin = {\n        top: 30,\n        left: 100 + (yAxisLabel ? labelOffset : 0),\n        right: 30,\n        bottom: 30 + (xAxisLabel ? labelOffset : 0)\n      };\n      const width = chartWidth - margin.left - margin.right;\n      const height = chartHeight - margin.top - margin.bottom;\n\n      /* Scales */\n      const xScale = d3\n        .scaleTime()\n        .domain(d3.extent(longestSeries.values, d => d.x))\n        .range([0, width]);\n      \n      const yScale = d3\n        .scaleLinear()\n        .domain([0, d3.max(longestSeries.values, d => d.y)])\n        .range([height - 0, 0]);\n\n      /* draw line fn for each series */\n      const drawLine = ({ values }) =>\n        d3\n          .line()\n          .x(d => xScale(d.x))\n          .y(d => yScale(d.y))(values);\n\n      const tooltip = d3.select(tooltipEl);\n\n      /* remove previously rendered, if any */\n      d3.select(`#${chartId} svg`).remove();\n      d3.select(`#${chartId} div`).remove();\n      tooltip.html(\"\");\n\n      /* SVG */\n      const svg = d3\n        .select(`#${chartId}`)\n        .append(\"svg\")\n        .attr(\"width\", width + margin.left + margin.right + \"px\")\n        .attr(\"height\", height + margin.top + margin.bottom + \"px\");\n\n      /* position main g element */\n      const g = svg\n        .append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, ${margin.top})`);\n\n      /* add axes */\n      const xAxis = d3\n        .axisBottom(xScale)\n        // .tickSize(0)\n        .tickFormat(multiDateFormat)\n        .ticks(xAxisTicksByInterval);\n\n      g.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", `translate(0, ${height})`)\n        .call(xAxis)\n        .selectAll(\"text\")\n        .attr(\"y\", axisOffset);\n\n      const yAxis = d3\n        .axisLeft(yScale)\n        .tickSize(-width)\n        .ticks(5)\n        .tickFormat(d3.format(\"\"))\n        .scale(yScale.nice());\n\n      g.append(\"g\")\n        .attr(\"class\", \"y axis\")\n        .call(yAxis)\n        .selectAll(\"text\")\n        .attr(\"x\", -axisOffset);\n\n      // Add X axis label\n      const xAxisTicksApproxHeight = 30;\n      const xLabelOffset = xAxisTicksApproxHeight + 21;\n      svg\n        .select(\".x.axis\")\n        .append(\"text\")\n        .text(xAxisLabel)\n        .attr(\"class\", \"line-graph-label\")\n        .attr(\"transform\", `translate(${width / 2}, ${xLabelOffset})`);\n\n      // Add Y axis label\n      svg\n        .select(\".y.axis\")\n        .append(\"text\")\n        .text(yAxisLabel)\n        .attr(\"class\", \"line-graph-label\")\n        .attr(\n          \"transform\",\n          `translate(${-labelOffset}, ${(height - margin.top) / 2}) rotate(-90)`\n        );\n\n      /* add series lines */\n      const lines = g.append(\"g\").attr(\"class\", \"lines\");\n\n      const series = lines\n        .selectAll(\".line-group\")\n        .data(data)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"line-group\");\n\n      series\n        .append(\"path\")\n        .attr(\"class\", \"line\")\n        .attr(\"d\", d => drawLine(d))\n        .style(\"stroke\", (d, i) => colors(i))\n        .style(\"opacity\", \"0.85\");\n\n      /* Tooltip reference point */\n      const tooltipRef = d3\n        .select(`#${chartId}`)\n        .append(\"div\")\n        .attr(\"class\", \"tooltip-ref\");\n\n      let tooltipPopper; /* init once, reuse popper */\n\n      const overlay = g.append(\"rect\");\n      overlay\n        .attr(\"class\", \"overlay\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .on(\"mousemove\", function() {\n          const [mouseX] = d3.mouse(this);\n          const xPoint = xScale.invert(mouseX);\n          const focusDataPoints = []; /* all dots on focused xAxis */\n\n          g.selectAll(\".circle\").remove(); /* remove rendered dots */\n\n          /* determine focus point from mouse hover X */\n          const { x: focusPoint } = getDatumInSeries({\n            series: longestSeries,\n            xPoint\n          });\n\n          /* for each series, render dot, push to array for tooltip render */\n          data.forEach((series, i) => {\n            const d = getDatumInSeries({ series, xPoint, focusPoint });\n            if (!d) return; /* skip if not focus point */\n            focusDataPoints.push({\n              ...d,\n              series: series.name,\n              color: colors(i)\n            });\n\n            /* dot on focus point */\n            const circleRadius = 3;\n            g.append(\"g\")\n              .attr(\"class\", \"circle\")\n              .append(\"circle\")\n              .style(\"fill\", colors(i))\n              .attr(\"cx\", xScale(d.x))\n              .attr(\"cy\", yScale(d.y))\n              .attr(\"r\", circleRadius);\n          });\n          /* update tooltip reference position */\n          tooltipRef\n            .style(\"left\", `calc(${xScale(focusPoint)}px + ${margin.left}px)`)\n            .style(\"transform\", `translateY(-50%)`)\n            .style(\"top\", `calc(50% - ${margin.top}px)`);\n\n          /* compose HTML for tooltip */\n          tooltip.style(\"display\", \"inherit\").html(\n            composeTooltipHTML({\n              focusDataPoints,\n              focusPoint\n            })\n          );\n\n          /* init popper once */\n          if (!tooltipPopper) {\n            const [tooltipRefEl] = tooltipRef.nodes();\n            tooltipPopper = initTooltipPopper(tooltipRefEl, tooltipEl);\n          }\n          /* update popper on mousemove */\n          if (tooltipPopper) tooltipPopper.update();\n        })\n        .on(\"mouseout\", function() {\n          const [mouseX, mouseY] = d3.mouse(this);\n          const maxWidth = overlay.node().getAttribute(\"width\");\n          const maxHeight = overlay.node().getAttribute(\"height\");\n          /* remove dots and tooltips */\n          if (\n            mouseX < 0 ||\n            mouseX >= maxWidth ||\n            mouseY < 0 ||\n            mouseY >= maxHeight\n          ) {\n            g.selectAll(\".circle\").remove();\n            tooltip.html(\"\");\n          }\n        });\n    },\n    graph_label(val){\n    let name_key = {\n      'all conversations':'all_conversations',\n      'user initiated':'user_initiated',\n      'business initiated':'business_initiated',\n      'free tier': 'free_tier',\n      'free entry':'free_entry',\n      'free conversations':'free_conversations',\n      'all paid':'all_paid',\n      'total':'total'\n    }\n     return Object.keys(name_key).find(key => name_key[key] === val);\n    }\n  },\n  mounted() {\n    this.renderChart();\n  }\n};\n</script>\n\n<style lang=\"scss\">\n@import \"@/portal/components/assets/base\";\n@import \"@/portal/components/assets/colors\";\n@import \"@/portal/components/assets/font\";\n\n[data-root] {\n  display: flex;\n  > [data-line-chart-legend],\n  > [data-line-chart] {\n    flex-flow: row wrap;\n  }\n  .line-chart-tooltip {\n    flex-direction: column;\n  }\n  [data-line-chart-legend] {\n    text-align: left;\n    width: 30%;\n    padding: 1.5rem;\n    color: $chart-axis-color;\n    border: 1px solid transparent;\n    border-left-color: $chart-border-color;\n    .legend-key {\n      @include titillium-web-semibold;\n      font-size: 1rem;\n      margin-bottom: 0.875rem;\n    }\n    ul {\n      padding: 0;\n      list-style-type: none;\n      li.legend-series {\n        @include titillium-web-regular;\n        font-size: 0.875rem;\n        margin-bottom: 0.875rem;\n        line-height: 1.3125rem;\n        height: 1.3125rem;\n        &:last-child {\n          margin-bottom: 0;\n        }\n        > div {\n          display: inline-block;\n        }\n        .legend-icon {\n          margin-right: 0.625rem;\n          width: 0.625rem;\n          height: 0.625rem;\n        }\n      }\n    }\n  }\n}\n[data-line-chart] {\n  font-size: 0.875rem;\n  position: relative;\n  .invalid-options {\n    border: 1px solid red;\n    padding: 1rem;\n  }\n  .overlay {\n    fill: none;\n    pointer-events: all;\n  }\n  .line {\n    stroke-width: 2;\n    fill: none;\n  }\n  .tick {\n    line {\n      stroke: $chart-border-color;\n    }\n  }\n  .axis {\n    .tick {\n      text {\n        @include titillium-web-regular;\n        font-size: 0.75rem;\n        fill: $chart-axis-color ;\n      }\n    }\n    &.y .domain {\n      display: none;\n    }\n  }\n  .tooltip-ref {\n    position: absolute;\n  }\n  .line-graph-label {\n    @include titillium-web-semibold;\n    font-size: 0.625rem;\n    text-transform: uppercase;\n    fill: $chart-axis-color;\n  }\n}\n\n$arrow-width: 0.5rem;\n.line-chart-tooltip {\n  @extend %transition-all-ease;\n  filter: drop-shadow(0 0px 2px $shadow-color);\n  display: none;\n  border: 1px solid $chart-border-color;\n  padding: 0;\n  background: $white;\n  // width: auto;\n  max-width: 15rem;\n\n  .popper-arrow {\n    width: 0;\n    height: 0;\n    margin: $arrow-width 0;\n    border: $arrow-width solid $white;\n    border-top-color: transparent;\n    border-bottom-color: transparent;\n    position: absolute;\n    top: calc(50% - #{$arrow-width});\n  }\n  &[x-placement^=\"right\"] {\n    margin-left: $arrow-width;\n    .popper-arrow {\n      border-left-width: 0;\n      left: -#{$arrow-width};\n    }\n  }\n  &[x-placement^=\"left\"] {\n    margin-right: $arrow-width;\n    .popper-arrow {\n      border-right-width: 0;\n      right: -#{$arrow-width};\n    }\n  }\n\n  .line-chart-tooltip-title {\n    @include titillium-web-semibold;\n    font-size: 0.875rem;\n    color: $chart-axis-color;\n    padding: 0.625rem 1rem;\n    line-height: 0.875rem;\n    border-bottom: 1px solid $chart-border-color;\n    text-align: left;\n  }\n\n  .series-container {\n    display: flex;\n    flex-flow: row wrap;\n    padding: 0.96875rem 1rem;\n    .series-row {\n      text-align: left;\n      width: 42%;\n      margin-bottom: 1rem;\n      padding-right: 1rem;\n      display: flex;\n      .color-bar {\n        margin-right: 0.59rem;\n        width: 4px;\n        height: 2rem;\n        line-height: 2rem;\n      }\n      .series-name {\n        @include titillium-web-regular;\n        @extend %truncate;\n        font-size: 0.75rem;\n        line-height: 0.875rem;\n        height: 0.875rem;\n        width: 4.5rem;\n      }\n      .series-value {\n        @include titillium-web-bold;\n        font-size: 1rem;\n        line-height: 0.875rem;\n        height: 0.875rem;\n      }\n    }\n  }\n}\n</style>\n"]}]}